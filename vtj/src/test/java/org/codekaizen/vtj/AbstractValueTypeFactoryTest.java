/*
 * Copyright (c) 2008 Kevin Brockhoff
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.codekaizen.vtj;

import static org.testng.Assert.assertFalse;
import static org.testng.Assert.fail;
import static junit.framework.Assert.assertTrue;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.math.MathContext;
import java.math.RoundingMode;
import java.util.HashMap;
import java.util.Map;
import org.testng.annotations.Test;


/**
 * <p>Base class for unit testing implementations of {@link ValueTypeFactory}.</p>
 *
 * @author  <a href="mailto:kbrockhoff@codekaizen.org">Kevin Brockhoff</a>
 */
public abstract class AbstractValueTypeFactoryTest {

    private final Class<?> testClass;
    private final Map<String, Object> configurationValues;
    private Constructor<?> constructor;

    /**
     * Constructs a value type factory tester.
     *
     * @param  testClass  the class to test
     *
     * @throws  IllegalArgumentException  if an invalid parameter is passed in
     */
    protected AbstractValueTypeFactoryTest(final Class<?> testClass) {
        super();
        AssertPrecondition.notNull("testClass", testClass);
        AssertPrecondition.isAssignable(ValueTypeFactory.class, testClass);
        this.testClass = testClass;
        configurationValues = new HashMap<String, Object>();

        try {
            constructor = testClass.getConstructor(ContextHandlingStrategy.class);
        } catch (final NoSuchMethodException nsme) {
            throw new IllegalArgumentException(nsme.getMessage());
        }
    }

    /**
     * Returns the factory class being tested.
     *
     * @return  the class
     */
    protected final Class<?> getTestClass() {
        return testClass;
    }

    /**
     * Returns a map that can be used to pass configuration values to new factories.
     *
     * @return  the writable map
     */
    protected final Map<String, Object> getConfigurationValues() {
        return configurationValues;
    }

    /**
     * Constructs a new configured factory.
     *
     * @return  the factory
     *
     * @throws  IllegalStateException  if unable to instantiate an instance of the class being tested
     */
    protected Object createFactory() {
        getConfigurationValues().put("org.codekaizen.base.MathContext", new MathContext(2, RoundingMode.HALF_EVEN));

        final ContextHandlingStrategy strategy = new MapContextHandlingStrategy();
        final ValueTypeFactory<?> factory;

        try {
            factory = (ValueTypeFactory<?>) constructor.newInstance(strategy);
        } catch (final IllegalAccessException e) {
            throw new IllegalStateException(e);
        } catch (final InstantiationException e) {
            throw new IllegalStateException(e);
        } catch (final InvocationTargetException e) {
            throw new IllegalStateException(e.getTargetException());
        }

        factory.setContext(getConfigurationValues());

        return factory;
    }

    /**
     * Verifies that <code>isCreatable</code> returns <code>true</code> if the base class generated by the factory is
     * passed in.
     */
    @Test(groups = { "api" })
    @SuppressWarnings("unchecked")
    public void shouldReturnCreatableOnClassFactoryNamedFor() {
        String name = getTestClass().getName();
        assertTrue(name.endsWith("Factory"));
        name = name.substring(0, name.length() - 7);

        Class<? extends ValueType<?>> clazz = null;

        try {
            clazz = (Class<? extends ValueType<?>>) Class.forName(name);
        } catch (final ClassNotFoundException e) {
            fail("cannot load " + name);
        }

        final ValueTypeFactory<?> factory = (ValueTypeFactory<?>) createFactory();
        assertTrue(factory.isCreatable(clazz));
        doTestIsCreatable();
    }

    /**
     * Abstract method verifying additional <code>isCreatable</code> functionality.
     */
    protected abstract void doTestIsCreatable();

    /**
     * Verifies <code>isCreatable</code> returns <code>false</code> if a <code>null</code> is passed in and does not
     * throw a <code>NullPointerException</code>.
     */
    @Test(groups = { "api" })
    public void shouldReturnNotCreatableForNull() {
        final ValueTypeFactory<?> factory = (ValueTypeFactory<?>) createFactory();
        assertFalse(factory.isCreatable(null));
    }

    /**
     * Verifies <code>create</code> can construct objects from one or more valid representations.
     */
    @Test(groups = { "api" })
    public void shouldCreateObjectFromMultipleRepresentations() {
        doTestCreateObjectArray();
    }

    /**
     * Abstract method verifying additional <code>create</code> functionality.
     */
    protected abstract void doTestCreateObjectArray();

    /**
     * Verifies <code>isParsable</code> returns <code>true</code> if string can be parsed.
     */
    @Test(groups = { "api" })
    public void shouldReturnParsableIfStringCanBeConverted() {
        doTestIsParsable();
    }

    /**
     * Abstract method verifying additional <code>isParsable</code> functionality.
     */
    protected abstract void doTestIsParsable();

    /**
     * Verifies <code>isParsable</code> returns <code>false</code> if a <code>null</code> is passed in and does not
     * throw a <code>NullPointerException</code>.
     */
    @Test(groups = { "api" })
    public void shouldReturnNotParsableForNull() {
        final ValueTypeFactory<?> factory = (ValueTypeFactory<?>) createFactory();
        assertFalse(factory.isParsable(null));
    }

    /**
     * Verifies that if <code>isParsable</code> returns <code>true</code> the string can actually be parsed.
     */
    @Test(groups = { "api" })
    public void shouldParseAnyStringIdentifiedAsParsable() {
        doTestParseString();
    }

    /**
     * Abstract method verifying additional parsing functionality.
     */
    protected abstract void doTestParseString();

    /**
     * Verifies that <code>format</code> returns a uniquely-identifiable string for the content passed in.
     */
    @Test(groups = { "api" })
    public void shouldBeAbleToUniquelyFormatAnyInstanceOfCreatableClass() {
        doTestFormatValueType();
    }

    /**
     * Abstract method verifying additional formatting functionality.
     */
    protected abstract void doTestFormatValueType();

}
